from CPU import *
from abstraction import *
import error
import re
import json

def get_ins():
    text = {'prog2.yo': "                            | # prog2: Pad with 2 nop's\n0x000: 30f20a00000000000000 |   irmovq $10,%rdx\n0x00a: 30f00300000000000000 |   irmovq  $3,%rax\n0x014: 10                   |   nop\n0x015: 10                   |   nop\n0x016: 6020                 |   addq %rdx,%rax\n0x018: 00                   |   halt\n", 'pushquestion.yo': '                            | \t# Assembly Code to test semantics of pushq\n0x000: 30f40001000000000000 | \tirmovq 0x100, %rsp\n0x00a: a04f                 | \tpushq %rsp  # Ambiguous\n0x00c: b00f                 | \tpopq  %rax\n0x00e: 00                   | \thalt\n', 'asumi.yo': '                            | # Execution begins at address 0 \n0x000:                      | \t.pos 0 \n0x000: 30f40001000000000000 | \tirmovq stack, %rsp  \t# Set up stack pointer  \n0x00a: 803800000000000000   | \tcall main\t\t# Execute main program\n0x013: 00                   | \thalt\t\t\t# Terminate program \n                            | \n                            | # Array of 4 elements\n0x018:                      | \t.align 8 \t\n0x018: 0d000d000d000000     | array:\t.quad 0x000d000d000d\n0x020: c000c000c0000000     | \t.quad 0x00c000c000c0\n0x028: 000b000b000b0000     | \t.quad 0x0b000b000b00\n0x030: 00a000a000a00000     | \t.quad 0xa000a000a000\n                            | \n0x038: 30f71800000000000000 | main:\tirmovq array,%rdi\t\n0x042: 30f60400000000000000 | \tirmovq $4,%rsi\n0x04c: 805600000000000000   | \tcall sum\t\t# sum(array, 4)\n0x055: 90                   | \tret \n                            | \n                            | /* $begin sumi-ys */\n                            | # long sum(long *start, long count)\n                            | # start in %rdi, count in %rsi\n0x056:                      | sum:\n0x056: 6300                 | \txorq %rax,%rax\t\t# sum = 0\n0x058: 6266                 | \tandq %rsi,%rsi\t\t# Set condition codes\n0x05a: 708300000000000000   | \tjmp    test\n0x063:                      | loop:\n0x063: 50a70000000000000000 | \tmrmovq (%rdi),%r10\t# Get *start\n0x06d: 60a0                 | \taddq %r10,%rax          # Add to sum\n0x06f: c0f70800000000000000 | \tiaddq $8,%rdi           # start++\n0x079: c0f6ffffffffffffffff | \tiaddq $-1,%rsi          # count--\n0x083:                      | test:\n0x083: 746300000000000000   | \tjne    loop             # Stop when 0\n0x08c: 90                   | \tret\n                            | /* $end sumi-ys */\n                            | \n                            | # The stack starts here and grows to lower addresses\n0x100:                      | \t.pos 0x100\t\t\n0x100:                      | stack:\t \n', 'prog6.yo': '                            | # Demonstration of return\n                            | # /* $begin prog6-ys */\n                            | # prog6\n0x000: 30f43000000000000000 |    irmovq stack,%rsp  #   Initialize stack pointer\n0x00a: 802000000000000000   |    call proc          #   Procedure call\n0x013: 30f20a00000000000000 |    irmovq $10,%rdx    #   Return point\n0x01d: 00                   |    halt\n0x020:                      | .pos 0x20\n0x020:                      | proc:                 # proc:\n0x020: 90                   |    ret                #   Return immediately\n0x021: 2023                 |    rrmovq %rdx,%rbx   #   Not executed\n0x030:                      | .pos 0x30\n0x030:                      | stack:                # stack: Stack pointer\n                            | # /* $end prog6-ys */\n', 'prog7.yo': '                            | # Demonstrate branch cancellation\n                            | # /* $begin prog7-ys */\n                            | # prog7\n0x000: 6300                 |    xorq %rax,%rax \n0x002: 741600000000000000   |    jne  target        # Not taken\n0x00b: 30f00100000000000000 |    irmovq $1, %rax    # Fall through\n0x015: 00                   |    halt\n0x016:                      | target:\n0x016: 30f20200000000000000 |    irmovq $2, %rdx    # Target\n0x020: 30f30300000000000000 |    irmovq $3, %rbx    # Target+1\n                            | # /* $end prog7-ys */\n0x02a: 00                   |    halt\n                            | \n', 'prog3.yo': '                            | # prog3: Pad with 1 nop\n0x000: 30f20a00000000000000 |   irmovq $10,%rdx\n0x00a: 30f00300000000000000 |   irmovq  $3,%rax\n0x014: 10                   |   nop\n0x015: 6020                 |   addq %rdx,%rax\n0x017: 00                   |   halt\n', 'prog8.yo': '                            | # prog8: Forwarding Priority\n0x000: 30f20a00000000000000 |   irmovq $10,%rdx\n0x00a: 30f20300000000000000 |   irmovq  $3,%rdx\n0x014: 2020                 |   rrmovq %rdx,%rax\n0x016: 00                   |   halt\n', 'pushtest.yo': '                            | # Test of Push semantics for Y86-64\n0x000: 30f40001000000000000 | \tirmovq $0x100,%rsp  # Initialize stack pointer\n0x00a: 2040                 | \trrmovq %rsp,%rax    # Save stack pointer\n0x00c: a04f                 | \tpushq %rsp          # Push the stack pointer (old or new?)\n0x00e: b02f                 | \tpopq  %rdx          # Get it back\n0x010: 6120                 | \tsubq  %rdx,%rax     # Compute difference.  Either 0 (old) or 4 (new).\n0x012: 00                   | \thalt\n', 'prog10.yo': '                            | # prog10\n0x000: 30f00100000000000000 |     irmovq $1,%rax\n0x00a: 6344                 |     xorq %rsp,%rsp        # Set stack pointer to 0 and CC to 100\n0x00c: a00f                 |     pushq %rax            # Attempt to write to 0xfffffffffffffff8\n0x00e: 6000                 |     addq  %rax,%rax       # (Should not be executed) Would set CC to 000\n0x010: 30f00200000000000000 |     irmovq $2, %rax       # Not executed\n0x01a: 30f00300000000000000 |     irmovq $3, %rax       # Not executed\n', 'prog9.yo': '                            | # Exception handling\n                            | # /* $begin prog9-yo */\n0x000: 6300                 |    xorq %rax,%rax \n0x002: 741600000000000000   |    jne  target      # Not taken\n0x00b: 30f00100000000000000 |    irmovq $1, %rax  # Fall through\n0x015: 00                   |    halt\n0x016:                      | target:\n0x016: ff                   |    .byte 0xFF       # Invalid instruction code\n                            | # /* $end prog9-yo */\n', 'abs-asum-cmov.yo': '                            | # Modification of asum code to compute absolute values of entries.\n                            | # This version uses a conditional move\n                            | # Execution begins at address 0 \n0x000:                      | \t.pos 0 \n0x000: 30f40002000000000000 | \tirmovq stack, %rsp  \t# Set up stack pointer  \n0x00a: 803800000000000000   | \tcall main\t\t# Execute main program\n0x013: 00                   | \thalt\t\t\t# Terminate program \n                            | \n                            | # Array of 4 elements\n0x018:                      | \t.align 8 \t\n0x018: 0d000d000d000000     | array:\t.quad 0x0000000d000d000d\n0x020: 40ff3fff3fffffff     | \t.quad 0xffffff3fff3fff40  # -0x000000c000c000c0\n0x028: 000b000b000b0000     | \t.quad 0x00000b000b000b00\n0x030: 0060ff5fff5fffff     | \t.quad 0xffff5fff5fff6000  # -0x0000a000a000a000  \n                            | \n0x038:                      | main:\n0x038: 30f71800000000000000 | \tirmovq array,%rdi\t\n0x042: 30f60400000000000000 | \tirmovq $4,%rsi\n0x04c: 805600000000000000   | \tcall absSum\t\t# absSum(array, 4)\n0x055: 90                   | \tret \n                            | \n                            | # long absSum(long *start, long count)\n                            | # start in %rdi, count in %rsi\n0x056:                      | absSum:\n0x056: 30f80800000000000000 | \tirmovq $8,%r8           # Constant 8\n0x060: 30f90100000000000000 | \tirmovq $1,%r9\t        # Constant 1\n0x06a: 6300                 | \txorq %rax,%rax\t\t# sum = 0\n0x06c: 6266                 | \tandq %rsi,%rsi\t\t# Set condition codes\n0x06e: 708d00000000000000   | \tjmp  test\n                            | /* $begin abs-sum-cmov-ys */\n0x077:                      | loop:\n0x077: 50a70000000000000000 | \tmrmovq (%rdi),%r10\t# x = *start\n0x081: 63bb                 | \txorq %r11,%r11          # Constant 0\n0x083: 61ab                 | \tsubq %r10,%r11\t\t# -x\n0x085: 26ba                 | \tcmovg %r11,%r10\t\t# If -x > 0 then x = -x\n0x087: 60a0                 | \taddq %r10,%rax          # Add to sum\n0x089: 6087                 | \taddq %r8,%rdi           # start++\n0x08b: 6196                 | \tsubq %r9,%rsi           # count--\n0x08d:                      | test:\n0x08d: 747700000000000000   | \tjne    loop             # Stop when 0\n                            | /* $end abs-sum-cmov-ys */\n0x096: 90                   | \tret\n                            | \n                            | # The stack starts here and grows to lower addresses\n0x200:                      | \t.pos 0x200\t\t\n0x200:                      | stack:\t \n', 'ret-hazard.yo': '                            | /* $begin ret-hazard-ys */\n                            | # Test instruction that modifies %esp followed by ret\n0x000: 30f34000000000000000 | \tirmovq mem,%rbx\n0x00a: 50430000000000000000 | \tmrmovq  0(%rbx),%rsp # Sets %rsp to point to return point\n0x014: 90                   | \tret\t\t     # Returns to return point \n0x015: 00                   | \thalt                 # \n0x016: 30f60500000000000000 | rtnpt:  irmovq $5,%rsi       # Return point\n0x020: 00                   | \thalt\n0x040:                      | .pos 0x40\n0x040: 5000000000000000     | mem:\t.quad stack\t     # Holds desired stack pointer\n0x050:                      | .pos 0x50\n0x050: 1600000000000000     | stack:\t.quad rtnpt          # Top of stack: Holds return point\n                            | /* $end ret-hazard-ys */\n', 'abs-asum-jmp.yo': '                            | # Modification of asum code to compute absolute values of entries.\n                            | # This version uses a conditional jump\n                            | # Execution begins at address 0 \n0x000:                      | \t.pos 0 \n0x000: 30f40002000000000000 | \tirmovq stack, %rsp  \t# Set up stack pointer  \n0x00a: 803800000000000000   | \tcall main\t\t# Execute main program\n0x013: 00                   | \thalt\t\t\t# Terminate program \n                            | \n                            | # Array of 4 elements\n0x018:                      | \t.align 8 \t\n0x018: 0d000d000d000000     | array:\t.quad 0x0000000d000d000d\n0x020: 40ff3fff3fffffff     | \t.quad 0xffffff3fff3fff40  # -0x000000c000c000c0\n0x028: 000b000b000b0000     | \t.quad 0x00000b000b000b00\n0x030: 0060ff5fff5fffff     | \t.quad 0xffff5fff5fff6000  # -0x0000a000a000a000  \n                            | \n0x038: 30f71800000000000000 | main:\tirmovq array,%rdi\t\n0x042: 30f60400000000000000 | \tirmovq $4,%rsi\n0x04c: 805600000000000000   | \tcall absSum\t\t# absSum(array, 4)\n0x055: 90                   | \tret \n                            | /* $begin abs-sum-jmp-ys */\n                            | # long absSum(long *start, long count)\n                            | # start in %rdi, count in %rsi\n0x056:                      | absSum:\n0x056: 30f80800000000000000 | \tirmovq $8,%r8           # Constant 8\n0x060: 30f90100000000000000 | \tirmovq $1,%r9\t        # Constant 1\n0x06a: 6300                 | \txorq %rax,%rax\t\t# sum = 0\n0x06c: 6266                 | \tandq %rsi,%rsi\t\t# Set condition codes\n0x06e: 709600000000000000   | \tjmp  test\n0x077:                      | loop:\n0x077: 50a70000000000000000 | \tmrmovq (%rdi),%r10\t# x = *start\n0x081: 63bb                 | \txorq %r11,%r11          # Constant 0\n0x083: 61ab                 | \tsubq %r10,%r11\t\t# -x\n0x085: 719000000000000000   | \tjle pos\t\t\t# Skip if -x <= 0\n0x08e: 20ba                 | \trrmovq %r11,%r10\t# x = -x\n0x090:                      | pos:\n0x090: 60a0                 | \taddq %r10,%rax          # Add to sum\n0x092: 6087                 | \taddq %r8,%rdi           # start++\n0x094: 6196                 | \tsubq %r9,%rsi           # count--\n0x096:                      | test:\n0x096: 747700000000000000   | \tjne    loop             # Stop when 0\n0x09f: 90                   | \tret\n                            | /* $end abs-sum-jmp-ys */\n                            | \n                            | # The stack starts here and grows to lower addresses\n0x200:                      | \t.pos 0x200\t\t\n0x200:                      | stack:\t \n', 'j-cc.yo': '0x000: 30f60100000000000000 | \t      irmovq $1, %rsi\n0x00a: 30f70200000000000000 | \t      irmovq $2, %rdi\n0x014: 30f50400000000000000 | \t      irmovq $4, %rbp\n0x01e: 30f0e0ffffffffffffff | \t      irmovq $-32, %rax\n0x028: 30f24000000000000000 | \t      irmovq $64, %rdx\n0x032: 6120                 | \t      subq %rdx,%rax\n0x034: 733f00000000000000   | \t      je target\n0x03d: 10                   | \t      nop\n0x03e: 00                   |               halt\n0x03f:                      | target:\n0x03f: 6062                 | \t      addq %rsi,%rdx\n0x041: 10                   | \t      nop\n0x042: 10                   |               nop\n0x043: 10                   |               nop\n0x044: 00                   | \t      halt\n', 'poptest.yo': '                            | # Test of Pop semantics for Y86-64\n0x000: 30f40001000000000000 | \tirmovq $0x100,%rsp  # Initialize stack pointer\n0x00a: 30f0cdab000000000000 | \tirmovq $0xABCD,%rax \n0x014: a00f                 | \tpushq  %rax         # Put known value on stack\n0x016: b04f                 | \tpopq   %rsp         # Either get 0xABCD, or 0xfc\n0x018: 00                   | \thalt\n', 'prog4.yo': '                            | # prog4: No padding\n0x000: 30f20a00000000000000 |   irmovq $10,%rdx\n0x00a: 30f00300000000000000 |   irmovq  $3,%rax\n0x014: 6020                 |   addq %rdx,%rax\n0x016: 00                   |   halt\n', 'cjr.yo': '                            | # /* $begin cjr-ys */\n                            | # Code to generate a combination of not-taken branch and ret\n0x000: 30f44000000000000000 | \tirmovq Stack, %rsp\n0x00a: 30f03800000000000000 | \tirmovq rtnp,%rax\n0x014: a00f                 | \tpushq %rax\t   # Set up return pointer\n0x016: 6300                 | \txorq %rax,%rax     # Set Z condition code\n0x018: 742c00000000000000   | \tjne target\t   # Not taken (First part of combination)\n0x021: 30f00100000000000000 |         irmovq $1,%rax     # Should execute this\n0x02b: 00                   | \thalt\n0x02c: 90                   | target:\tret\t\t   # Second part of combination\n0x02d: 30f30200000000000000 | \tirmovq $2,%rbx\t   # Should not execute this\n0x037: 00                   | \thalt\n0x038: 30f20300000000000000 | rtnp: \tirmovq $3,%rdx     # Should not execute this\n0x042: 00                   | \thalt\n0x040:                      | .pos 0x40\n0x040:                      | Stack:\n                            | # /* $end cjr-ys */\n', 'prog1.yo': "                            | # prog1: Pad with 3 nop's\n0x000: 30f20a00000000000000 |   irmovq $10,%rdx\n0x00a: 30f00300000000000000 |   irmovq  $3,%rax\n0x014: 10                   |   nop\n0x015: 10                   |   nop\n0x016: 10                   |   nop\n0x017: 6020                 |   addq %rdx,%rax\n0x019: 00                   |   halt\n", 'asum.yo': '                            | # Execution begins at address 0 \n0x000:                      | \t.pos 0\n0x000: 30f40002000000000000 | \tirmovq stack, %rsp  \t# Set up stack pointer\n0x00a: 803800000000000000   | \tcall main\t\t# Execute main program\n0x013: 00                   | \thalt\t\t\t# Terminate program \n                            | \n                            | # Array of 4 elements\n0x018:                      | \t.align 8\n0x018: 0d000d000d000000     | array:\t.quad 0x000d000d000d\n0x020: c000c000c0000000     | \t.quad 0x00c000c000c0\n0x028: 000b000b000b0000     | \t.quad 0x0b000b000b00\n0x030: 00a000a000a00000     | \t.quad 0xa000a000a000\n                            | \n0x038: 30f71800000000000000 | main:\tirmovq array,%rdi\n0x042: 30f60400000000000000 | \tirmovq $4,%rsi\n0x04c: 805600000000000000   | \tcall sum\t\t# sum(array, 4)\n0x055: 90                   | \tret\n                            | \n                            | # long sum(long *start, long count)\n                            | # start in %rdi, count in %rsi\n0x056: 30f80800000000000000 | sum:\tirmovq $8,%r8        # Constant 8\n0x060: 30f90100000000000000 | \tirmovq $1,%r9\t     # Constant 1\n0x06a: 6300                 | \txorq %rax,%rax\t     # sum = 0\n0x06c: 6266                 | \tandq %rsi,%rsi\t     # Set CC\n0x06e: 708700000000000000   | \tjmp     test         # Goto test\n0x077: 50a70000000000000000 | loop:\tmrmovq (%rdi),%r10   # Get *start\n0x081: 60a0                 | \taddq %r10,%rax       # Add to sum\n0x083: 6087                 | \taddq %r8,%rdi        # start++\n0x085: 6196                 | \tsubq %r9,%rsi        # count--.  Set CC\n0x087: 747700000000000000   | test:\tjne    loop          # Stop when 0\n0x090: 90                   | \tret                  # Return\n                            | \n                            | # Stack starts here and grows to lower addresses\n0x200:                      | \t.pos 0x200\n0x200:                      | stack:\n', 'prog5.yo': '                            | # prog5: Load/use hazard\n0x000: 30f28000000000000000 |   irmovq $128,%rdx\n0x00a: 30f10300000000000000 |   irmovq  $3,%rcx\n0x014: 40120000000000000000 |   rmmovq %rcx, 0(%rdx)\n0x01e: 30f30a00000000000000 |   irmovq  $10,%rbx\n0x028: 50020000000000000000 |   mrmovq 0(%rdx), %rax  # Load %rax\n0x032: 6030                 |   addq %rbx,%rax        # Use %rax\n0x034: 00                   |   halt\n', 'asumr.yo': '                            | # Execution begins at address 0 \n0x000:                      | \t.pos 0 \n0x000: 30f40002000000000000 | \tirmovq stack, %rsp  \t# Set up stack pointer  \n0x00a: 803800000000000000   | \tcall main\t\t# Execute main program\n0x013: 00                   | \thalt\t\t\t# Terminate program \n                            | \n                            | # Array of 4 elements\n0x018:                      | \t.align 8 \t\n0x018: 0d000d000d000000     | array:\t.quad 0x000d000d000d\n0x020: c000c000c0000000     | \t.quad 0x00c000c000c0\n0x028: 000b000b000b0000     | \t.quad 0x0b000b000b00\n0x030: 00a000a000a00000     | \t.quad 0xa000a000a000\n                            | \n0x038: 30f71800000000000000 | main:\tirmovq array,%rdi\t\n0x042: 30f60400000000000000 | \tirmovq $4,%rsi\n0x04c: 805600000000000000   | \tcall rsum\t\t# rsum(array, 4)\n0x055: 90                   | \tret\n                            | \n                            | /* $begin rsum-ys */\n                            | # long rsum(long *start, long count)\n                            | # start in %rdi, count in %rsi\n0x056:                      | rsum:\n0x056: 6300                 | \txorq %rax,%rax\t\t# Set return value to 0\n0x058: 6266                 | \tandq %rsi,%rsi\t\t# Set condition codes\n0x05a: 719400000000000000   | \tjle     return\t\t# If count <= 0, return 0\n0x063: a03f                 | \tpushq %rbx\t\t# Save callee-saved register\n0x065: 50370000000000000000 | \tmrmovq (%rdi),%rbx\t# Get *start\n0x06f: 30faffffffffffffffff | \tirmovq $-1,%r10\n0x079: 60a6                 | \taddq %r10,%rsi\t\t# count--\n0x07b: 30fa0800000000000000 | \tirmovq $8,%r10          \n0x085: 60a7                 | \taddq %r10,%rdi          # start++\n0x087: 805600000000000000   | \tcall rsum\n0x090: 6030                 | \taddq %rbx,%rax          # Add *start to sum\n0x092: b03f                 | \tpopq %rbx\t\t# Restore callee-saved register\n0x094:                      | return:\n0x094: 90                   | \tret\n                            | /* $end rsum-ys */\n                            | \n                            | # The stack starts here and grows to lower addresses\n0x200:                      | \t.pos 0x200\t\t\n0x200:                      | stack:\t \n                            | \n'}
    return text['abs-asum-cmov.yo']


def get_ins_test():
    return  '0x030:                      | stack:                # stack'

def str_to_byte_ls(input_str: str):
    str_lines = input_str.splitlines(False)
    adr_of_ins = []
    ins = []
    for ins_str in str_lines:
        try:
            this_adr = re.match("^0x(.*?):\s", ins_str).group(1)
            this_ins = re.match("^0x.*?:\s*(.*)\s*\|", ins_str).group(1).strip()
        except AttributeError:
            continue
        
        if this_ins is not None and this_ins != '':
            adr_of_ins.append(int(this_adr, base=16))
            ins.append(this_ins)
    return adr_of_ins, ins

def build_json_dic(cpu:CPU):
    cpu_info = {'PC':cpu.PC, 'REG':cpu.registers.get_reg_dict(), 'CC': cpu.cond_code.get_CC_dict()\
        , 'STAT': cpu.stat.val, 'MEM': cpu.memory.get_mem_dict()} # current state of the cpu stored in a python dict
    return cpu_info

if __name__ == '__main__':
    adr_ls, ins_str_ls = str_to_byte_ls(get_ins())
    byte_ls = []
    for ins_str, adr in zip(ins_str_ls, adr_ls):
        assert len(byte_ls) <= adr
        # The instructions are not necessarily 'tightly' arranged in memory.
        # So we need to check and shift the adr when initiallizing it.
        while len(byte_ls) < adr:
            byte_ls.append(Byte(0x0))
        for i in range(0, len(ins_str), 2):
            byte_ls.append(Byte('0x' + ins_str[i: i + 2]))

    '''
    in machine code the value is already stored by little endian....
    val_byte_ls = []
    for i in range(val_start, len(ins_str), 2):
        val_byte_ls.append(Byte('0x' + ins_str[i: i + 2]))
    val_byte_ls.reverse()
    '''

    print([byte.get_str_hex() for byte in byte_ls])
    print(len(byte_ls))
    mem = Memory(byte_ls)
    print(mem.mem_bytes[0x37].get_str_hex())
    cpu = CPU(mem)
    cpu_info_dict_ls = []

    while True:
        try:
            cpu.cycle()
            cpu.show_cpu(show_regs=True)
            cpu.memory.show_mem()
            print('\n')
            cpu_info_dict_ls.append(build_json_dic(cpu))
        except error.Error:
            break

    with open('./out.json', 'w') as fw:
        json.dump(cpu_info_dict_ls, fw)
    

